# Summary

* [简介](README.md)
* [第2章 创建和销毁对象](第2章 创建和销毁对象/介绍.md)
  * [第1条：用静态工厂方法代替构造器](第2章 创建和销毁对象/第1条：用静态工厂方法代替构造器.md)
  * [第2条：遇到多个构造器参数时要考虑使用构建器](第2章 创建和销毁对象/第2条：遇到多个构造器参数时要考虑使用构建器.md)
  * [第3条：用私有构造器或者枚举类型强化Singleton属性](第2章 创建和销毁对象/第3条：用私有构造器或者枚举类型强化Singleton属性.md)
  * [第4条：通过私有构造器强化不可实例化的能力](第2章 创建和销毁对象/第4条：通过私有构造器强化不可实例化的能力.md)
  * [第5条：优先考虑依赖注入来引用资源](第2章 创建和销毁对象/第5条：优先考虑依赖注入来引用资源.md)
  * [第6条：避免创建不必要的对象](第2章 创建和销毁对象/第6条：避免创建不必要的对象.md)
  * [第7条：消除过期的对象引用](第2章 创建和销毁对象/第7条：消除过期的对象引用.md)
  * [第8条：避免使用终结方法和清除方法](第2章 创建和销毁对象/第8条：避免使用终结方法和清除方法.md)
  * [第9条：try-with-resources优先于try-finally](第2章 创建和销毁对象/第9条：try-with-resources优先于try-finally.md)
* [第3章 对于所有对象都通用的方法](第3章 对于所有对象都通用的方法/介绍.md)
  * [第10条：覆盖equals时请遵守通用约定](第3章 对于所有对象都通用的方法/第10条：覆盖equals时请遵守通用约定.md)
  * [第11条：覆盖equals时总要覆盖hashCode](第3章 对于所有对象都通用的方法/第11条：覆盖equals时总要覆盖hashCode.md)
  * [第12条：始终要覆盖toString](第3章 对于所有对象都通用的方法/第12条：始终要覆盖toString.md)
  * [第13条：谨慎地覆盖clone](第3章 对于所有对象都通用的方法/第13条：谨慎地覆盖clone.md)
  * [第14条：考虑实现Comparable接口](第3章 对于所有对象都通用的方法/第14条：考虑实现Comparable接口.md)
* [第4章 类和接口](第4章 类和接口/介绍.md)
  * [第15条：使类和成员的可访问性最小化](第4章 类和接口/第15条：使类和成员的可访问性最小化.md)
  * [第16条：要在公有类而非公有域中使用访问方法](第4章 类和接口/第16条：要在公有类而非公有域中使用访问方法.md)
  * [第17条：使可变性最小化](第4章 类和接口/第17条：使可变性最小化.md)
  * [第18条：复合优先于继承](第4章 类和接口/第18条：复合优先于继承.md)
  * [第19条：要么设计继承并提供文档说明，要么禁止继承](第4章 类和接口/第19条：要么设计继承并提供文档说明，要么禁止继承.md)
  * [第20条：接口优于抽象类](第4章 类和接口/第20条：接口优于抽象类.md)
  * [第21条：为后代设计接口](第4章 类和接口/第21条：为后代设计接口.md)
  * [第22条：接口只用于定义类型](第4章 类和接口/第22条：接口只用于定义类型.md)
  * [第23条：类层次优于标签类](第4章 类和接口/第23条：类层次优于标签类.md)
  * [第24条：静态成员类优于非静态成员类](第4章 类和接口/第24条：静态成员类优于非静态成员类.md)
  * [第25条：限制源文件为单个顶级类](第4章 类和接口/第25条：限制源文件为单个顶级类.md)
* [第5章 泛型](第5章 泛型/介绍.md)
  * [第26条：请不要使用原生态类型](第5章 泛型/第26条：请不要使用原生态类型.md)
  * [第27条：消除非受检的警告](第5章 泛型/第27条：消除非受检的警告.md)
  * [第28条：列表优于数组](第5章 泛型/第28条：列表优于数组.md)
  * [第29条：优先考虑泛型](第5章 泛型/第29条：优先考虑泛型.md)
  * [第30条：优先考虑泛型方法](第5章 泛型/第30条：优先考虑泛型方法.md)
  * [第31条：利用有限制通配符来提升API的灵活性](第5章 泛型/第31条：利用有限制通配符来提升API的灵活性.md)
  * [第32条：谨慎并用泛型和可变参数](第5章 泛型/第32条：谨慎并用泛型和可变参数.md)
  * [第33条：优先考虑类型安全的异构容器](第5章 泛型/第33条：优先考虑类型安全的异构容器.md)
* [第6章 枚举和注解](第6章 枚举和注解/介绍.md)
  * [第34条：用enum代替int常量](第6章 枚举和注解/第34条：用enum代替int常量.md)
  * [第35条：用实例域代替序数](第6章 枚举和注解/第35条：用实例域代替序数.md)
  * [第36条：用EnumSet代替位域](第6章 枚举和注解/第36条：用EnumSet代替位域.md)
  * [第37条：用EnumMap代替序数索引](第6章 枚举和注解/第37条：用EnumMap代替序数索引.md)
  * [第38条：用接口模拟可扩展的枚举](第6章 枚举和注解/第38条：用接口模拟可扩展的枚举.md)
  * [第39条：注解优先于命名模式](第6章 枚举和注解/第39条：注解优先于命名模式.md)
  * [第40条：坚持使用Override注解](第6章 枚举和注解/第40条：坚持使用Override注解.md)
  * [第41条：用标记接口定义类型](第6章 枚举和注解/第33条：优先考虑类型安全的异构容器.md)
* [第7章 Lambda和Stream](第7章 Lambda和Stream/介绍.md)
  * [第42条：Lambda优先于匿名类](第7章 Lambda和Stream/第42条：Lambda优先于匿名类.md)
  * [第43条：方法引用优先于Lambda](第7章 Lambda和Stream/第43条：方法引用优先于Lambda.md)
  * [第44条：坚持使用标准的函数接口](第7章 Lambda和Stream/第44条：坚持使用标准的函数接口.md)
  * [第45条：谨慎使用Stream](第7章 Lambda和Stream/第45条：谨慎使用Stream.md)
  * [第46条：优先选择Stream中无副作用的函数](第7章 Lambda和Stream/第46条：优先选择Stream中无副作用的函数.md)
  * [第47条：Stream要优先用Collection作为返回类型](第7章 Lambda和Stream/第47条：Stream要优先用Collection作为返回类型.md)
  * [第48条：谨慎使用Stream并行](第7章 Lambda和Stream/第48条：谨慎使用Stream并行.md)
* [第8章 方法](第8章 方法/介绍.md)
  * [第49条：检查参数的有效性](第8章 方法/第49条：检查参数的有效性.md)
  * [第50条：必要时进行保护性拷贝](第8章 方法/第50条：必要时进行保护性拷贝.md)
  * [第51条：谨慎设计方法签名](第8章 方法/第51条：谨慎设计方法签名.md)
  * [第52条：慎用重载](第8章 方法/第52条：慎用重载.md)
  * [第53条：慎用可变参数](第8章 方法/第53条：慎用可变参数.md)
  * [第54条：返回零长度的数组或者集合，而不是null](第8章 方法/第54条：返回零长度的数组或者集合，而不是null.md)
  * [第55条：谨慎返回optinal](第8章 方法/第55条：谨慎返回optinal.md)
  * [第56条：为所有导出的API元素编写文档注释](第8章 方法/第56条：为所有导出的API元素编写文档注释.md)
* [第9章 通用编程](第9章 通用编程/介绍.md)
  * [第57条：将局部变量的作用域最小化](第9章 通用编程/第57条：将局部变量的作用域最小化.md)
  * [第58条：for-each循环优先于传统的for循环](第9章 通用编程/第58条：for-each循环优先于传统的for循环.md)
  * [第59条：了解和使用类库](第9章 通用编程/第59条：了解和使用类库.md)
  * [第60条：如果需要精确的答案，请避免使用float和double](第9章 通用编程/第60条：如果需要精确的答案，请避免使用float和double.md)
  * [第61条：基本类型优先于装箱基本类型](第9章 通用编程/第61条：基本类型优先于装箱基本类型.md)
  * [第62条：如果其他类型更适合，则尽量避免使用字符串](第9章 通用编程/第62条：如果其他类型更适合，则尽量避免使用字符串.md)
  * [第63条：了解字符串连接的性能](第9章 通用编程/第63条：了解字符串连接的性能.md)
  * [第64条：通过接口引用对象](第9章 通用编程/第64条：通过接口引用对象.md)
  * [第65条：接口优先于反射机制](第9章 通用编程/第65条：接口优先于反射机制.md)
  * [第66条：谨慎地使用本地方法](第9章 通用编程/第66条：谨慎地使用本地方法.md)
  * [第67条：谨慎地进行优化](第9章 通用编程/第67条：谨慎地进行优化.md)
  * [第68条：遵守普遍接受的命名惯例](第9章 通用编程/第68条：遵守普遍接受的命名惯例.md)

* [第10章 异常](第10章 异常/介绍.md)
  * [第69条：只针对异常的情况才使用异常](第10章 异常/第69条：只针对异常的情况才使用异常.md)
  * [第70条：对可恢复的情况使用受检异常，对编程错误使用运行时异常](第10章 异常/第70条：对可恢复的情况使用受检异常，对编程错误使用运行时异常.md)
  * [第71条：避免不必要地使用受检异常](第10章 异常/第71条：避免不必要地使用受检异常.md)
  * [第72条：优先使用标准的异常](第10章 异常/第72条：优先使用标准的异常.md)
  * [第73条：抛出与抽象对应的异常](第10章 异常/第73条：抛出与抽象对应的异常.md)
  * [第74条：每个方法抛出的所有异常都要建立文档](第10章 异常/第74条：每个方法抛出的所有异常都要建立文档.md)
  * [第75条：在细节消息中包含失败-捕获信息](第10章 异常/第75条：在细节消息中包含失败-捕获信息.md)
  * [第76条：努力使失败保持原子性](第10章 异常/第76条：努力使失败保持原子性.md)
  * [第77条：不要忽略异常](第10章 异常/第77条：不要忽略异常.md)
* [第11章 并发](第11章 并发/介绍.md)
  * [第78条：同步访问共享的可变数据](第11章 并发/第78条：同步访问共享的可变数据.md)
  * [第79条：避免过度同步](第11章 并发/第79条：避免过度同步.md)
  * [第80条：executor、task和stream优先于线程](第11章 并发/第80条：executor、task和stream优先于线程.md)
  * [第81条：并发工具优先于wait和notify](第11章 并发/第81条：并发工具优先于wait和notify.md)
  * [第82条：线程安全性的文档化](第11章 并发/第82条：线程安全性的文档化.md)
  * [第83条：慎用延迟初始化](第11章 并发/第83条：慎用延迟初始化.md)
  * [第84条：不要依赖于线程调度器](第11章 并发/第84条：不要依赖于线程调度器.md)
* [第12章 序列化](第12章 序列化/介绍.md)
  * [第85条：其他方法优先于Java序列化](第12章 序列化/第85条：其他方法优先于Java序列化.md)
  * [第86条：谨慎地实现Serializable接口](第12章 序列化/第86条：谨慎地实现Serializable接口.md)
  * [第87条：考虑使用自定义的序列化形式](第12章 序列化/第87条：考虑使用自定义的序列化形式.md)
  * [第88条：保护性地编写readObject方法](第12章 序列化/第88条：保护性地编写readObject方法.md)
  * [第89条：对于实例控制，枚举类型优先于readResolve](第12章 序列化/第89条：对于实例控制，枚举类型优先于readResolve.md)
  * [第90条：考虑用序列化代理代替序列化实例](第12章 序列化/第90条：考虑用序列化代理代替序列化实例.md)

  